# 一、JS部分

## 1.ES6

http://interview.poetries.top/docs/design-pattern.html#es6

### 1. let 和 const

1. 一个声明变量，一个声明常量，两个都不能重复声明已经声明过的数据（`var` 可以）
2. `let`和`const`不存在变量提升，而`var`和function声明的函数有变量提升
3. 有暂时性死区

### 2. 箭头函数

- 参数如果只有一个，可以不加圆括号 `()`；
- 没有参数时，不能省略圆括号 `()`；
- 如果函数体只返回单一表达式，那么函数体可以不使用大括号 `{}` 和 `return`，直接写表达式即可；
- 在 3 的基础上，如果返回值是一个对象字面量，那么返回值需要加圆括号 `()`，避免被识别为代码块。
- 不能用作构造函数

箭头函数不会创建自己的this，因此不能用call、apply、bind来绑定this

### 3. class类

在ES6中直接使用class关键字来声明类

### 4. 解构赋值

数组解构和对象解构

### 5. 扩展运算符

### 6. 默认参数

### 7. Set

https://es6.ruanyifeng.com/#docs/set-map

### 8. Promise

https://es6.ruanyifeng.com/#docs/promise

1. Promise.prototype.then()
2. Promise.prototype.catch()
3. Promise.prototype.finally()
4. Promise.all() (所有都为fulfilled，p才为fulfilled，只要有一个为reject，p就为reject)
5. Promise.any()（只要有一个实例返回fulfilled就算成功，否则返回reject）
6. Promise.race()（只要有一个状态发生了改变，p的状态就变成这个状态）
7. Promise.allSettled()（当所有实例都返回结果后，最后的p的状态总是为fulfilled）
8. Promise.resolve()
9. Promise.reject()

## 2. 闭包

例子：https://segmentfault.com/a/1190000002957434

详解：https://www.jianshu.com/p/21a16d44f150

setTimeout：https://www.jianshu.com/p/9b4a54a98660

闭包就是可以访问函数内部变量的函数，她是一个定义在函数内部的函数，基于JS的垃圾回收机制，函数内部定义的变量在函数调用后就会被回收，如果想这个变量不被回收，并且能被外部函数调用的话，就可以使用闭包。

作用：读取函数内部变量，让这个函数中定义的变量始终保持在内存中，可以说是函数内部和外部沟通的桥梁

## 3. 执行上下文和作用域

https://www.cnblogs.com/love-life-insist/p/9063104.html

https://www.tyrocoder.cn/2020/05/28/JavaScript%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/

JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，执行上下文在这个阶段中的执行代码前创建。

## 4. 数据结构

## 5. 数据类型、深浅拷贝

- 基本数据类型：`undefined`、`null`、`boolean`、`number`、`string`、`symbol`  存放在栈中
- 引用数据类型：`object`、`array`、`function`   栈中存放堆中的引用地址

https://www.jianshu.com/p/87375f9a4725

## 6. this

https://www.runoob.com/w3cnote/js-call-apply-bind.html

## 7. 函数

函数声明，函数表达式，匿名函数，立即执行函数

## 8. for in 和 for of

https://www.jianshu.com/p/ee21c4c86d5d

## 11.prototype和 __proto__

https://blog.csdn.net/cc18868876837/article/details/81211729

![image-20210430164440372](C:\Users\73699\AppData\Roaming\Typora\typora-user-images\image-20210430164440372.png)

```js
  console.log(Date.prototype)
  const time = new Date()

  console.log(time)
  console.log(time.__proto__) 
```

Date的prototype指向的是函数Date的原型对象，   -------显式原型

new出来的实例time的 `__proto__`的原型对象也指向同一个地址 --------隐式原型

```js
function Gouzhaoqi(){

    }
    console.log(Gouzhaoqi.prototype)
    const shili = new Gouzhaoqi()
    console.log(shili.__proto__)

    //  构造器上的原型对象指向的地址  和   实例上的__proto__原型对象指向的地址是同一个地址
    
    // 验证： 改变值
    Gouzhaoqi.prototype.changeme = function(){
      console.log('changeme')
    }
    console.log(Gouzhaoqi.prototype)
    console.log(shili.__proto__) //当我修改了构造函数的prototype原型属性时，
                                  // 已经在修改之前生成的实例上的__proto__属性也会改变
```

1。每个构造函数function都有一个prototype，即显式原型(属性)

2．每个实例对象都有一个_proto_，可称为隐式原型(属性)

3．对象的隐式原型的值为其对应构造函数的显式原型的值

4.内存结构(图)

5.总结:
0函数的prototype属性:在定义函数时自动添加的，默认值是一个空object对象
对象的__proto__属性:创建对象时自动添加的，默认值为构造函数的prototype属性值程序员能直接操作显式原型，但不能直接操作隐式原型(ES6之前)

6.面试回答：

一个构造函数有一个显式原型prototype

通过构造函数生成的实例有一个隐式原型 `__proto__`，

他们都指向同一个地址，也就是他们的值是相等的

prototype是在定义构造函数时生成的，`__proto__`是在生成实例的时候生成的

当访问一个实例上的一个属性时，如果在实例身上没有这个属性就会去她的隐式原型`__proto__`上去找，一直找下去，向父对象再向爷爷对象，如果最后返回null则没有这个值，这样，通过`__proto__`属性将对象连接起来的这条链路就叫原型链

## 12. 数组去重、字符串去重

```js
var a =	[1,2,2,3]
var b = [...new Set(a)]
```

```js
var a = 'aabbccdff'
var b = [...new Set(a)].join('')
```

## 13. 交换两个变量，不使用第三个变量

https://blog.csdn.net/jdz321/article/details/46950285

## 14. 图片懒加载和预加载

## 15.数组和链表的区别

https://blog.csdn.net/qq_25806863/article/details/70607204



# 二、浏览器部分

## 1. http和https有什么区别

大致理解：https = http + ssl协议 + 证书

http采用80端口， https采用443端口

https://www.cnblogs.com/spll/p/10565189.html

## 2. http和tcp\ip的关系

网络的七层协议：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层

http是应用层，解决如何包装数据，它是基于TCP进行连接的

TCP|IP是传输层和网络层，解决数据如何在网络中传输

https://www.cnblogs.com/xianlei/p/tcpip_http.html

## 3. https的连接过程

https://www.cnblogs.com/liyuhui-Z/p/7844880.html

https://blog.csdn.net/alan_gui/article/details/87180100?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-0&spm=1001.2101.3001.4242

## 4. tcp和udp的区别

- `TCP`是一个面向连接的、可靠的、基于字节流的传输层协议。
- `UDP`是一个面向无连接的传输层协议。
- `TCP`为什么可靠，是因为它有三次握手来保证双方都有接受和发送数据的能力。

## 5. tcp的三次握手和四次挥手

#### 三次握手

第一次：客户端发出请求TCP报文给服务端，我想连接你：我可以发数据

第二次：服务端收到请求结束listen阶段，返回TCP报文给客户端：我可以收到数据，也可以发数据，并且同意创建新连接

第三次：客户端收到信息，明确两者之间是可以正常传输数据的，并返回一段TCP报文：我可以收到信息

#### 四次挥手

第一次：客户端请求断开连接，发送数据给服务端：我想断开连接了，进入等待，但是还能收到从客户端发过来的信息

第二次：服务端收到消息，返回信息给客户端：我知道你想断开连接了，我也开始准备释放连接

第三次：服务端继续返回信息给服务器端：我已经准备好了可以释放，此时停止传输到客户端，但是能接受客户端发来的请求，（等待1msl，如果没搜到客户端的返回信息，就再发一遍）

第四次：服务器端收到请求，返回信息我知道你要释放连接了，我也即将断开（等待2msl，如多又收到了信息，则说明客户端没有收到返回信息，就再发一次，如果没有收到就彻底断开连接）

https://baijiahao.baidu.com/s?id=1654225744653405133&wfr=spider&for=pc

## 6. http请求方式

https://www.cnblogs.com/xianlei/p/Http.html

### http响应消息由状态行、消息报头、空行和响应正文

```
HTTP/1.1 200 OK
Date: Fri, 22 May 2009 06:07:21 GMT
Content-Type: text/html; charset=UTF-8

<html>
      <head></head>
      <body>
            <!--body goes here-->
      </body>
</html>
```

### 请求方法

HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。
HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。 

> GET     请求指定的页面信息，并返回实体主体。（get可以带json，但是得转码）
> HEAD     类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头
> POST     向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中，POST请求可能会导致新的资源的建立和/或已有资源的修改。
> PUT     从客户端向服务器传送的数据取代指定的文档的内容。
> DELETE      请求服务器删除指定的页面。
> CONNECT     HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。
> OPTIONS     允许客户端查看服务器的性能。
> TRACE     回显服务器收到的请求，主要用于测试或诊断。

### PUT和POST

 PUT和POST都有更改指定URI的语义.但PUT被定义为idempotent的方法，POST则不是.idempotent的方法:如果一个方法重复执行多次，产生的效果是一样的，那就是idempotent的。也就是说：

PUT请求：如果两个请求相同，后一个请求会把第一个请求覆盖掉。（所以PUT用来改资源）

Post请求：后一个请求不会把第一个请求覆盖掉。（所以Post用来增资源）

### GET和POST的区别

1. 1. GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&相连，如EditPosts.aspx?name=test1&id=123456. POST方法是把提交的数据放在HTTP包的Body中.
   2. GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.
   3. GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。
   4. GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.

## 7. 性能优化

#### 图片懒加载

#### 路由懒加载

#### cdn

> `CDN`的原理是尽可能的在各个地方分布机房缓存数据，这样即使我们的根服务器远在国外，在国内的用户也可以通过国内的机房迅速加载资源。

> 因此，我们可以将静态资源尽量使用 `CDN` 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 `CDN` 域名。并且对于 `CDN` 加载静态资源需要注意 `CDN` 域名要与主站不同，否则每次请求都会带上主站的 `Cookie`，平白消耗流量



# 三、HTML部分

# 四、CSS部分

## 1. 实现水平垂直居中的方法

flex布局、高度确定子绝父相、高度不确定transform

## 2. position定位

relative、absolute、fixed

https://www.runoob.com/w3cnote/css-position-static-relative-absolute-fixed.html

## 3. 圣杯模型

## 4. CSS3新增属性

border、background、transform、transition

https://blog.csdn.net/weixin_45959504/article/details/103790736

## 5. 伪类和伪元素

https://blog.csdn.net/liwenfei123/article/details/80682156

## 6. em和rem

https://www.cnblogs.com/wind-lanyan/p/6978084.html

注意chrome的最小字体为12px

## 7.盒模型

https://blog.csdn.net/zwkkkk1/article/details/79678177

ie和W3C

## 8. BFC

https://www.jianshu.com/p/0fb2f90418c3

1.解决同一个 BFC 下margin重叠问题

2.BFC(父元素)可以包含浮动的子元素（给父元素添加BFC可以清除子元素的浮动）（高度坍塌）

3.BFC可以阻止元素被浮动元素覆盖（将被覆盖的元素添加BFC，可以不被浮动的元素覆盖）

## 9. 怎么样让一个元素消失

display: none;	元素消失，页面元素没有，无占位，元素上的时间不能执行

visibility: hidden;	元素消失，页面元素存在，并且占位，元素上的事件不能执行

opacity: 0;	元素消失，页面元素存在，并且占位，元素上的时间能够执行（只是透明度为0）

# 五、Vue

## 1. 生命周期

http://interview.poetries.top/docs/simply.html#_7-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F

http://interview.poetries.top/fe-vue-docs/docs/vue-component.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F (明了)

beforeCreate   created 

beforeMount   mounted

beforeUpdate   updated

beforeDestroy   destroyed

## 2. 路由跳转方式

一般有两种：

1. 通过 `<router-link to="home">`，router-link 标签会渲染为 `<a>` 标签，在 template 中的跳转都是用这种；
2. 另一种是编程式导航，也就是通过 JS 跳转，比如 `router.push('/home')`。

## 3.  v-show 与 v-if 区别

http://interview.poetries.top/fe-vue-docs/docs/vue-component.html#v-show-%E4%B8%8E-v-if-%E5%8C%BA%E5%88%AB

## 4.  计算属性和 watch 的区别

我的理解： 一个计算一个想要计算的值，直接对它进行计算，对应的直接是想要的结果

watch是这个值在改变，然后会导致页面其他部分发生变化，对应的是导致变化的原因

# 六、React

